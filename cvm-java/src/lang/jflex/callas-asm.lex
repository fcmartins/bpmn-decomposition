package org.callas.vm.parse;

/**
 * The lexicon of the Callas assembly.
 *
 * @author Tiago Cogumbreiro
 * @version $Id: callas-asm.lex,v 1.1 2011/02/08 20:18:46 cogumbreiro Exp $
 */

%%

%cup
%type java_cup.runtime.Symbol
%char

%class Lex
%column
%line

%{
    private StringBuffer buffer;

    /** Issue an error.
     * @param m Message
     */
    private void error(String m) { System.err.println((yyline + 1) + "." + yycolumn + ":" + m); }

    /**
     * A token built from a kind and value.
     * @param kind The kind of the token, usually an integer of the
     * enumeration class <pre>sym</pre> generated by CUP
     * @param value The value of the token
     */
    private java_cup.runtime.Symbol token(int kind, Object value) {
          return new java_cup.runtime.Symbol(kind, yyline,
                          yycolumn, value);
    }
    /**
     * A token built from its type and from the String at <pre>yytext()</pre>.
     * @param kind The kind of the token, usually an integer of the
     * enumeration class <pre>sym</pre> generated by CUP
     */
    private java_cup.runtime.Symbol token(int kind) {
        return token(kind,  yytext());
    }
%}

%eofval{
    return new java_cup.runtime.Symbol(sym.EOF);
%eofval}


%state STRING
%state COMMENT


blanks   = [\ \t\n]+
comment  = [//;].*
digit    = [0-9]
positive = 0|[1-9]{digit}*
integer  = "-"?{positive}

/* double literals, stolen from JFlex examples */         
DoubleLiteral = ({FLit1}|{FLit2}|{FLit3}) {Exponent}?
FLit1    = [0-9]+ \. [0-9]* 
FLit2    = \. [0-9]+ 
FLit3    = [0-9]+ 
Exponent = [eE] [+-]? [0-9]+

%%
<YYINITIAL> {
"BOOL"     { return token(sym.BOOL); }
"DOUBLE"   { return token(sym.DOUBLE); }
"LONG"     { return token(sym.LONG); }
"STRING"   { return token(sym.STRING); }
"MODULE"   { return token(sym.MODULE); }
"SYMBOLS"  { return token(sym.SYMBOLS); }
"LOCALS"   { return token(sym.LOCALS); }
"CODE"     { return token(sym.CODE); }
"FUNCTION" { return token(sym.FUNCTION); }
"PARAMETERS" { return token(sym.PARAMETERS); }
"FREEVARS" { return token(sym.FREEVARS); }
"update"   { return token(sym.UPDATE); }
"extern"   { return token(sym.EXTERN); }
"call"     { return token(sym.CALL); }
"timer"    { return token(sym.TIMER); }
"goto"     { return token(sym.GOTO); }
"return"   { return token(sym.RETURN); }
"receive"  { return token(sym.RECEIVE); }
"send"     { return token(sym.SEND); }
"load"     { return token(sym.LOAD); }
"loadm"    { return token(sym.LOADM); }
"loadb"    { return token(sym.LOADB); }
"loadc"    { return token(sym.LOADC); }
"storeb"   { return token(sym.STOREB); }
"store"    { return token(sym.STORE); }
"ladd"     { return token(sym.LADD); }
"dadd"     { return token(sym.DADD); }
"lneg"     { return token(sym.LNEG); }
"dneg"     { return token(sym.DNEG); }
"lsub"     { return token(sym.LSUB); }
"dsub"     { return token(sym.DSUB); }
"lmul"     { return token(sym.LMUL); }
"dmul"     { return token(sym.DMUL); }
"ldiv"     { return token(sym.LDIV); }
"ddiv"     { return token(sym.DDIV); }
"de"       { return token(sym.DEQ); }
"le"       { return token(sym.LEQ); }
"lrem"     { return token(sym.LREM); }
"lxor"     { return token(sym.LXOR); }
"lshr"     { return token(sym.LSHR); }
"lshl"     { return token(sym.LSHL); }
"land"     { return token(sym.LAND); }
"lor"      { return token(sym.LOR); }
"bnot"     { return token(sym.BNOT); }
"lnot"     { return token(sym.LNOT); }
"band"     { return token(sym.BAND); }
"bor"      { return token(sym.BOR); }
"bxor"     { return token(sym.BXOR); }
"leq"      { return token(sym.LEQ); }
"deq"      { return token(sym.DEQ); }
"lgt"      { return token(sym.LGT); }
"llt"      { return token(sym.LLT); }
"dgt"      { return token(sym.DGT); }
"dlt"      { return token(sym.DLT); }
"pop"      { return token(sym.POP); }
"dup"      { return token(sym.DUP); }
"swap"     { return token(sym.SWAP); }
"iftrue"   { return token(sym.IFTRUE); }

{integer}  { return token(sym.LONG_VALUE, Long.valueOf(yytext())); }
{DoubleLiteral} { return token(sym.DOUBLE_VALUE, Double.valueOf(yytext())); }
\"         { buffer = new StringBuffer(); yybegin(STRING); }
"/*"       { yybegin(COMMENT); }
{blanks}   { }
{comment}  { }
.                       { error("Illegal character " + yytext()); }
}

<STRING>{
\\\\            { buffer.append("\\"); }
\\\"            { buffer.append("\""); }
\\n             { buffer.append("\n"); }
\\t             { buffer.append("\t"); }

\"              { yybegin(YYINITIAL); return token(sym.STRING_VALUE, buffer.toString());}
\n              { buffer.append("\n"); }
\r              { }
.               { buffer.append(yytext()); }
}

<COMMENT>{
"*/"            { yybegin(YYINITIAL); }
.               { }
}
