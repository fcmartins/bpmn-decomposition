package org.tyco.common.util;

import org.tyco.common.errorMsg.ErrorMsg;
/**
 * A class for performing the lexical analysis of a source file.
 * To handle file inclusion, it maintains a stack of Lexical Analisers,
 * accessed via openFile and closeFile operations.
 *
 * @author  Vasco T. Vasconcelos
 * @version $Id$
 */
public class Scanner implements Lexer {

	/**
	 * The stack of Lexers
	 */
	private java.util.Stack<IncludeLexer> lexers;

	/**
	 * Error message manager
	 */
	private ErrorMsg errorMsg;

	/**
	 * The eof token, usually an integer of the
	 * enumeration class <code>sym</code> generated by CUP
	 */
	private int eofToken;
	
	/** 
	 * The depth of the comment.
	 * 0 means we are not within a comment
	 */
	private int commentLevel;

	/**
	 * A buffer for string processing.
	 * Null means we are not within a string
	 */
	private StringBuffer strbuf;

	/**
	 * Construct given a lexer, its pathname, an error message manager,
	 * and the integer for EOF.
	 * @param errorMsg The error message manager
	 * @param eofToken The token for EOF, usually an integer of the
	 * enumeration class <pre>sym</pre> generated by CUP
	 */
	public Scanner(ErrorMsg errorMsg, int eofToken) {
		this.errorMsg = errorMsg;
		this.eofToken = eofToken;
		this.lexers = new java.util.Stack<IncludeLexer> ();
	}
	
	// OPENING and CLOSING FILES
	
	/**
	 * Open a new file.
	 * 
	 * @param lexer The lexer for the file to be opened
	 * @param filename The canonical filename
	 * @param pos The number of the character within the current file
	 */
	public void openFile (Lexer lexer, String filename, int pos) {
		commentLevel = 0;
		strbuf = null;
		errorMsg.newfile(currentPos(pos), filename);
		lexers.push(new IncludeLexer(lexer, currentPos(pos), new java.io.File(
				filename).getParent()));
	}

	/**
	 * Close an included file
	 * @param pos The number of the character within the current file
	 * @return The EOF token if this was the last file in the stack,
	 * otherwise, the first token of the next file in the stack
	 * @throws java.io.IOException 
	 */
	public java_cup.runtime.Symbol closeFile (int pos) throws java.io.IOException{
		checkCanClose (pos);
		int currentPos = currentPos (pos);
		lexers.pop ();
		java_cup.runtime.Symbol result = null;
		if (lexers.isEmpty ()) {
			result = new java_cup.runtime.Symbol (eofToken, currentPos, 0, "end of file");
		}
		else {
			errorMsg.endfile (currentPos);
			endfile(pos);
			result = nextToken ();
		}
		return result;
	}
	
	/**
	 * Pop a lexer from the stack; update that at the top.
	 * @param pos The number of the character within the current file
	 */
	private void endfile (int pos) {
		commentLevel = 0;
		strbuf = null;
		topLexer().posOffset += pos;
	}
	
	/**
	 * Check whether we are within a comment or a string;
	 * issue an error if not
	 * @param pos The number of the character within the current file
	 */
	private void checkCanClose (int pos) {
		if (commentLevel > 0)
			error (pos, "\nUnclosed comment at end of file");
		if (strbuf != null)
			error (pos, "\nUnclosed string at end of file");		
	}
	
	/**
	 * The canonical name of a filename, concatenated with the current
	 * directory, if relative.
	 * 
	 * @see java.io.File.getCanonicalPath
	 * @param filename The filename, relative or absolute
	 * @param pos The number of the character (needed in case of error)
	 * @return The canonical path of the file name, or null if IO exception
	 */
	public String canonicalPath (String filename, int pos) {
		String absolute =
			new java.io.File(filename).isAbsolute() ?
			filename :
			topLexer().path + java.io.File.separator + filename;
		try {
			return new java.io.File(absolute).getCanonicalPath();
		}
		catch (java.io.FileNotFoundException e) {
			error(pos, "\nFile " + absolute + " not found.");
		}
		catch (java.io.IOException e) {
			error(pos, "\nPath problem with file " + absolute + ".");		
		}
		return null;
	}

	/**
	 * The next token
	 */
	public java_cup.runtime.Symbol nextToken() throws java.io.IOException {
		// The parser seems to call this function after an eof, hence the test
		return
			lexers.isEmpty() ?
			new java_cup.runtime.Symbol (eofToken, 0, 0, "end of file") :
			topLexer().lexer.nextToken();
	}
	
	/**
	 * Issue an error
	 * @param pos The number of the character within the current file
	 * @param msg The error message
	 */
	public void error (int pos, String msg) {
		errorMsg.error (currentPos (pos), msg);
	}

	/**
	 * Issue a newline
	 * @param pos The number of the character within the current file
	 */
	 public void newline (int pos) {
	 	errorMsg.newline (currentPos (pos));
	 }

	// COMMENT HANDLING
	
	/**
	 * Entering a new comment
	 */
	public void openComment () {
		commentLevel++;
	}
	
	/**
	 * Leaving a comment
	 */
	public void closeComment () {
		commentLevel--;
	}
	
	/**
	 * Is the comment level zero?
	 * @return if the comment level is zero.
	 */
	public boolean backToCode () {
		return commentLevel == 0;
	}
	
	//  STRING HANDLING
	
	/**
	 * Start a new String.
	 */
	public void startString () {
		strbuf = new StringBuffer();
	}

	/**
	 * Append a string to the current string
	 * @param str The string to append
	 */
	public void append (String str) {
		strbuf.append (str);
	}
	
	/**
	 * Close a string;
	 * @return the current string
	 */
	public String closeString () {
		String result = strbuf.toString();
		strbuf = null;
		return result;
	}
	
	// BUILDING TOKENS
	
	/**
	 * A token built from a kind and value.
	 * @param kind The kind of the token, usually an integer of the
	 * enumeration class <pre>sym</pre> generated by CUP
	 * @param pos 
	 * @param len 
	 * @param value The value of the token
	 * @return Returns a new symbol.
	 */
	public java_cup.runtime.Symbol token (int kind, int pos, int len, Object value) {
		return new java_cup.runtime.Symbol (kind, currentPos (pos), currentPos (pos) + len, value);
	}

	/**
	 * The number of the character
	 * @param charNo The number of the character within the current file
	 */
	private int currentPos (int pos) {
		return pos + (lexers.empty() ? 0 : topLexer().posOffset);
	}

	/**
	 * The lexer at the top of the stack
	 */
	private IncludeLexer topLexer () {
		return lexers.peek();
	}

	/**
	 * A lexical analyser supporting file inclusion. 
	 */
	private class IncludeLexer {
		/**
		 * The lexer of this file
		 */
		Lexer lexer;
		/**
		 * The number of the character at the start of the file
		 */		
		int posOffset;
		/**
		 * The path to the directory where the file lives
		 */
		String path;

		IncludeLexer (Lexer lexer, int pos, String path) {
			this.lexer = lexer;
			this.posOffset = pos;
			this.path = path;
		}
	}
}
